<html>
<head>
  <meta name="description" content="EFHTEST">
  <meta charset="utf-8">
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>EFHTEST</title>
  <style>
    html,
    body,
    #viewDiv {
      padding: 0;
      margin: 0;
      height: 100%;
      width: 100%;
    }
    #header {
      padding-top: 5px;
      padding-bottom: 5px;
      margin: auto;
      height: 40px;
      width: 100%;
      background-color: #00467F;
      text-align: center;
    }
   .dropbtn {
     background-color: #00467F;
     color: white;
     padding: 9px;
     font-size: 16px;
     font-family:'verdana';
     border: none;
     cursor: pointer;
  }

  .dropbtn:hover, .dropbtn:focus {
     background-color: #00067F;
  }

  .dropdown {
     float: right;
     position: relative;
     display: inline-block;
  }

  .about-content {
     display: none;
     position: absolute;
     right: 0;
     background-color: #f1f1f1;
     border-style: solid;
     border-width: 1px;
     border-color: black;
     min-width: 350px;
     overflow: auto;
     box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
     z-index: 1;
     font-family:'verdana';
     font-size: 13px;
     padding: 5px;

  }
  .show {display: block;}
  </style>
  <link rel="stylesheet" href="https://js.arcgis.com/4.15/esri/themes/light/main.css">
  <script src="https://js.arcgis.com/4.15/"></script>
</head>

<script>
  require([
      "esri/Map",
      "esri/views/MapView",
      "esri/layers/FeatureLayer",
      "esri/layers/GraphicsLayer",
      "esri/Graphic",
      "esri/widgets/Search",
      "esri/tasks/Locator",
      "esri/widgets/BasemapToggle",
      "esri/widgets/Popup",
      "esri/views/draw/PolygonDrawAction",
      "esri/views/draw/Draw"
    ],
    function(
      Map, MapView, FeatureLayer, GraphicsLayer, Graphic, Search, Locator, BasemapToggle, Popup, PolygonDrawAction, Draw) {
      
      //base map set to topography
      var map = new Map({
        basemap: "topo-vector"
      });

      //View centered on Galvestion/Houston
      var view = new MapView({
        container: "viewDiv",
        map: map,
        center: [-94.82100,29.55100],
        zoom: 8,
        popup: {
            dockEnabled: true,
            dockOptions: {
              // Disables the dock button from the popup
              buttonEnabled: false,
              // Ignore the default sizes that trigger responsive docking
              breakpoint: false
            }
          },
      });
      const draw = new Draw({
          view: view
      });
    
      //Addition of widget toggling the basemap from topography to satellite view
      var basemapToggle = new BasemapToggle({
        view: view,
        nextBasemap: "hybrid"
      });
      view.ui.add(basemapToggle, "bottom-right");
    
      //Addition of the search widget to allow it to search lat/longs and current location for querying
      var searchWidget = new Search ({ 
        view: view,
        includeDefaultSources: false,
        popupEnabled: false,
        resultGraphicEnabled: false,
        sources: [{//This is the source that allows for querying lat/long
              locator: new Locator({ url: "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer" }),
              placeholder: "Enter Lat/Long",
              singleLineFieldName: "SingleLine",
              outFields: ["Address"],
              name: "ArcGIS World Geocoding Service",
              suggestionsEnabled: false,
              
            }],
        locationEnabled: true
      });
      view.ui.add(searchWidget, "top-right");
    
      //Addition of the button found on the query results window that pops up, used for downloading a CSV file
      var downloadReportAction = {
          title: "Download CSV",
          id: "downloadReport",
          image: "https://umiami.maps.arcgis.com/sharing/rest/content/items/f2676983a0ed4e769e2e09ab7bf0b8eb/data"
      };

      //Query results window added with no information
      var infoWindow = new Popup ({
        view: view,
        actions: [downloadReportAction]
      });
      view.ui.add(infoWindow);
    
      view.ui.add("line-button", "top-left");
    
     //Load in the feature layers used for querying depth/habitat/species parameter

      var habitatLayer = new FeatureLayer ({
        url: "https://services1.arcgis.com/B4MnusZHL3vmqU3t/arcgis/rest/services/ccap_2016_landcover_GulfSansFL/FeatureServer"
      });
      var parameterTable = new FeatureLayer ({
        url: "https://services1.arcgis.com/B4MnusZHL3vmqU3t/arcgis/rest/services/EFHQueryTable/FeatureServer"
      }); 
      var testTable = new FeatureLayer ({
        url: "https://services1.arcgis.com/B4MnusZHL3vmqU3t/arcgis/rest/services/features/FeatureServer"
      });
    
      var habitat; //A variable that holds the habitat grid code for querying
      var reportText; //The information that returned in the downloaded report
      var queryPolygon = false;
      var stateRow = null;
    
    function queryTable(){
        var name = []; //Array holding species common names
        var lifestage = []; //Array holding species lifestages
        var windowText = []; //Text to display on the pop up info window
        var salMin = []; //Array for minimum salinity
        var salMax = []; //Array for maximum salinity
        reportText = ["Species,common_name,Life_stage,salinity_low,salinity_high,depth_low,depth_high,TX,LA,MS,AL,FL,GA,SC,NC"
];//Populate the report text with column headers
       
       //Switch case for the queried habitat grid codes, depending on the habitat, the queried salinity high and low changes
       switch(habitat){
         case 13: //Palustrine Forested Wetland
           console.log("Case 13");
           var tableQuery = {
            outFields: ["*"],
            where: "(salinity_low <= 4) AND (salinity_high >= 0) AND (" + stateRow + " = 'Y')"
           }
           habitat = 0;
           break;
         case 14: //Palustrine Scrub/Scrub Wetland
           console.log("Case 14");
           var tableQuery = {
            outFields: ["*"],
            where: "(salinity_low <= 4) AND (salinity_high >= 0) AND (" + stateRow + " = 'Y')"
           }
           habitat = 0;
           break;
         case 15: //Palustrine Emergent Wetland
           console.log("Case 15");
           var tableQuery = {
            outFields: ["*"],
            where: "(salinity_low <= 4) AND (salinity_high >= 0) AND (" + stateRow + " = 'Y')"
           }
           habitat = 0;
           break;
         case 16: //Estuarine Forested Wetland
           console.log("Case 16");
           var tableQuery = {
            outFields: ["*"],
            where: "(salinity_low <= 38) AND (salinity_high >= 5) AND (" + stateRow + " = 'Y')"
           }
           habitat = 0;
           break;
         case 17: //Estuarine Scrub/Scrub Wetland
           console.log("Case 17");
           var tableQuery = {
            outFields: ["*"],
            where: "(salinity_low <= 38) AND (salinity_high >= 5) AND (" + stateRow + " = 'Y')"
           }
           habitat = 0;
           break;
         case 18: //Estuarine Emergent Wetland
           console.log("Case 18");
           var tableQuery = {
            outFields: ["*"],
            where: "(salinity_low <= 38) AND (salinity_high >= 5) AND (" + stateRow + " = 'Y')"
           }
           habitat = 0;
           break;
         case 19: //Unconsolidated Shore
           console.log("Case 19");
           var tableQuery = {
            outFields: ["*"],
            where: "(" + stateRow + " = 'Y')"
           }
           habitat = 0;
           break;
         case 21: //Open Water
           console.log("Case 21");
           var tableQuery = {
            outFields: ["*"],
            where: "(" + stateRow + " = 'Y')"
           }
           habitat = 0;
           break;
         case 22: //Palustrine Aquatic Bed
           console.log("Case 22");
           var tableQuery = {
            outFields: ["*"],
            where: "(salinity_low <= 4) AND (salinity_high >= 0) AND (" + stateRow + " = 'Y')"
           }
           habitat = 0;
           break;
         case 23: //Estuarine Aquatic Bed
           console.log("Case 23");
           var tableQuery = {
            outFields: ["*"],
            where: "(salinity_low <= 38) AND (salinity_high >= 5) AND (" + stateRow + " = 'Y')"
           }
           habitat = 0;
           break;
         default: //If the area has no discernable habitat,
           console.log("Default")
           var tableQuery = {
            outFields: ["*"],
            where: "'common_name' = 'Nothing'"
           }
       }
          //Query species parameter table using the query generated by the switch case
      console.log(tableQuery);
          parameterTable.queryFeatures(tableQuery).then(function(result) {
                  result.features.forEach(function(feature){
                    if(feature.attributes.common_name != name[name.length-1]){
                      name.push(feature.attributes.common_name);
                      windowText.push("<b>"+feature.attributes.common_name+"</b><li>"+feature.attributes.life_stage+"</li>");
                    }
                    else{
                      windowText.push("<li>"+feature.attributes.life_stage+"</li>");
                    }
                    reportText.push(feature.attributes.Species+","+feature.attributes.common_name+","+feature.attributes.life_stage+","+feature.attributes.salinity_low+","+feature.attributes.salinity_high+","+feature.attributes.depth_low+","+feature.attributes.depth_high+","+feature.attributes.TX+","+feature.attributes.LA+","+feature.attributes.MS+","+feature.attributes.AL+","+feature.attributes.FL+","+feature.attributes.GA+","+feature.attributes.SC+","+feature.attributes.NC);
                  });
              
                 if(name[0] != null) {
                      infoWindow.title = "EFH Species Found:";
                      infoWindow.content = windowText.join(""); 
                      infoWindow.actions = [downloadReportAction];
                      infoWindow.visible = true;
                 }
                 else{
                   infoWindow.title = "No EFH Species found in this area";
                   infoWindow.content = "There are a few reasons why an EFH may have not been found here: <li>The habitat may not be suitable to facilitate any EFH species' life stage.</li><li>The depth may not be suitable to facilitate any EFH species' life stage.</li><li>This area may be out of range of this state's designation for EFH species.</li><li>An EFH designation may still be nearby this specific area. If unsure, check other points near the area.</li>"; 
                   infoWindow.actions = [];
                 }
            queryPolygon = false;
           });
        return true;
      }
    
    function queryFeatureLayerView(shape, spatialRelationship, sqlExpression){
        infoWindow.title = "Searching for an EFH";
        infoWindow.content = "Please wait a moment..."; 
        infoWindow.actions = [];
       
        console.log(shape);
        if (!map.findLayerById(habitatLayer.id)) {
          habitatLayer.outFields = ["*"];
        }
        var habitatQuery = {
          geometry: shape,
          distance: 30,
          units: "meters",
          spatialRelationship: spatialRelationship,
          outFields: ["*"],
          returnGeometry: false,
          where: sqlExpression
        }; 
        habitatLayer.queryFeatures(habitatQuery).then(function(result) {
                    result.features.forEach(function(feature){
                      
                      if(feature.attributes.gridcode > 15 || feature.attributes.gridcode != 22){
                          habitat = feature.attributes.gridcode;
                          //console.log("Habitat" + feature.attributes.gridcode);
                      }
                      else{
                          habitat = feature.attributes.gridcode;
                          //console.log("Habitat" + feature.attributes.gridcode);
                      }
                      
                      stateRow = feature.attributes.State;
                    }); 
                      console.log("habitat: " + habitat);
                      queryTable();
                    });      
      
      return true;
      }
    
    function createPolygonGraphic(vertices, polyComplete){
      view.graphics.removeAll();
      var polygon = {
        type: "polygon", // autocasts as Polygon
        rings: vertices,
        spatialReference: view.spatialReference
      };

      var graphic = new Graphic({
        geometry: polygon,
        symbol: {
          type: "simple-fill", // autocasts as SimpleFillSymbol
          color: [15, 15, 128, 0.5],
          style: "solid",
          outline: {  // autocasts as SimpleLineSymbol
            color: "black",
            width: 1
          }
        }
      });
      view.graphics.add(graphic);
      if(polyComplete){
        infoWindow.visible = true;
        queryFeatureLayerView(polygon, "intersects");
      }
    }
    
    function enableCreatePolygon(draw, view) {
      var action = draw.create("polygon");
      // PolygonDrawAction.vertex-add
      // Fires when user clicks, or presses the "F" key.
      // Can also be triggered when the "R" key is pressed to redo.
      action.on("vertex-add", function (evt) {
        createPolygonGraphic(evt.vertices, false);
      });

      // PolygonDrawAction.vertex-remove
      // Fires when the "Z" key is pressed to undo the last added vertex
      action.on("vertex-remove", function (evt) {
        createPolygonGraphic(evt.vertices, false);
      });

      // Fires when the pointer moves over the view
      action.on("cursor-update", function (evt) {
        createPolygonGraphic(evt.vertices, false);
      });

      // Add a graphic representing the completed polygon
      // when user double-clicks on the view or presses the "C" key
      action.on("draw-complete", function (evt) {
        createPolygonGraphic(evt.vertices, true);
      });
    }
    
     
      
     function downloadReport() {
        var reportFile = document.createElement('a');
        reportFile.setAttribute('href', 'data:text/plain;charset=utf-8,' +  encodeURIComponent(reportText.join("\n")));
        reportFile.setAttribute('download', "test.csv");

        reportFile.style.display = 'none';
        reportFile.click();
      }

      view.on("click", function(event){
        
        infoWindow.location = event.mapPoint;
        if(!queryPolygon){
          view.graphics.removeAll();
          if(queryFeatureLayerView(event.mapPoint, "intersects")){
             infoWindow.visible = true;
             searchWidget.searchTerm = event.mapPoint.latitude.toFixed(4) + ", " + event.mapPoint.longitude.toFixed(4);
          }
          else{
             infoWindow.visible = false;
          }
        }
        
      });
    
      searchWidget.on("search-start", function(){
        infoWindow.visible = false;
        if(!queryPolygon){
          view.graphics.removeAll();
          searchWidget.goToOverride = function(view, goToParams) {
              goToParams.target.zoom = 8;
              goToParams.options.durations = 0;
              console.log(goToParams)
              queryFeatureLayerView(goToParams.target.target.center, "intersects");
              queryTable();
              infoWindow.location = goToParams.target.target.center;
              return view.goTo(goToParams.target, goToParams.options);     
          };
          console.log(searchWidget.searchTerm);
          console.log(view.viewpoint.targetGeometry);
          queryTable();
          infoWindow.visible = true;
        }
      });
    
      infoWindow.on("trigger-action", function (event) {
          if (event.action.id === "downloadReport") {
            console.log("Hello");
            downloadReport();
          }
      });
    
    document.getElementById("line-button").onclick = function () {
          view.graphics.removeAll();
          infoWindow.visible = false;
          // creates and returns an instance of PolyLineDrawAction
          const action = draw.create("polyline");

          // focus the view to activate keyboard shortcuts for sketching
          view.focus();
          queryPolygon = true;
          enableCreatePolygon(draw, view)
    };
      
    });
    
  </script>
</head>
<body>
  <div id="header">
    <t style="color:white; font-family:'verdana'; font-size: 190%;" > 
       Inland Test Mapper 
    </t>
    <div class="dropdown">
      <button onclick="dropDownFunction()" class="dropbtn">About</button>
      <div id="aboutMenu" class="about-content">
        <p align = "center" >The Inland EFH Mapper informs users of potential essential fishery habitats (EFHs), displaying the species and their lifestages at a provided coordinate.</p>
        <p align = "center" >The mapping tool responds to two styles of input:
        <li align = "center" >By clicking/touching your specific area of interest.</li>
        <li align = "center" >Entering in a "latitude, longitude" or current location in the search.</li>
        <li align = "center" >By clicking the draw icon on the top left of the map, you can draw a polygon representing your project area. Simply start the polygon by click somewhere on the map, and continue adding points until you have covered your project area. Double click to finish your area. The project area will disappear once you click somewhere on the map or click the draw icon again.</li></p>
         <p align = "center" >You will see a window pop up on the map explaining whether an EFH was found, followed by species common name and their life stages.
        </p>
        <p align = "center" >A CSV is available to download for your point of interest by clicking the "Download CSV" button located at the bottom left of the results window pop up. This CSV will include the resulting species, scientific names, life stages, minimum and maximum depth and salinity, and states where they are commonly found.</p>
        <p align = "center" >For more information on offshore EFH designations, or visible EFH boundaries, please visit the NOAA EFH Mapper tool (Link here).</p>
      </div>
    </div>
    <script>
    //Toggles showing the content of the instructional menu
    function dropDownFunction() {
      document.getElementById("aboutMenu").classList.toggle("show");
    }

    // Close the dropdown if the user clicks outside of it
    window.onclick = function(event) {
      if (!event.target.matches('.dropbtn')) {
        var dropdowns = document.getElementsByClassName("about-content");
        var i;
        for (i = 0; i < dropdowns.length; i++) {
          var openDropdown = dropdowns[i];
          if (openDropdown.classList.contains('show')) {
            openDropdown.classList.remove('show');
          }
        }
      }
    }
    </script>
  </div>
  <div id="viewDiv">
    <div
        id="line-button"
        class="esri-widget esri-widget--button esri-interactive"
        title="Draw polyline"
      >
        <span class="esri-icon-polyline"></span>
      </div>
  </div>
  
</body>

</html>
